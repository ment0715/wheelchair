import cv2
import numpy as np
import RPi.GPIO as GPIO # 라즈베리파이 GPIO 핀을 쓰기위해 임포트
from time import sleep  #time 라이브러리의 sleep함수 사용
from gpiozero import LED
from gpiozero import Robot
from gpiozero import Motor
import time


red_ledL = LED(19)
red_ledR = LED(26)
dc_motorL = Motor(forward = 16, backward = 12)
dc_motorR = Motor(forward = 20, backward = 21)

cap = cv2.VideoCapture(0) #0번카메라 = 눈 = 좌,우회전
cap1 = cv2.VideoCapture(2) #2번카메라 = 손 = 운전

while True:
    ret, frame = cap.read()
    ret1, frame1 = cap1.read()
    
    if ret is False:
        break
        
    if ret1 is False:
        break    
   
    roi = frame[250: 500, 900: 1300] 
    roi1 = frame1[100: 795, 300: 1300]
    
    rows, cols, _ = roi.shape
    rows1, cols1, _ = roi1.shape
 
    gray_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY) 
    gray_roi1 = cv2.cvtColor(roi1, cv2.COLOR_BGR2GRAY) 
   
    gray_roi = cv2.GaussianBlur(gray_roi, (7, 7), 0) 
    gray_roi1 = cv2.GaussianBlur(gray_roi1, (7, 7), 0)
    
    _, threshold = cv2.threshold(gray_roi, 33, 255, cv2.THRESH_BINARY_INV)
    _, threshold1 = cv2.threshold(gray_roi1, 25, 255, cv2.THRESH_BINARY_INV)
    
    _, contours, _ = cv2.findContours(threshold, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    contours = sorted(contours, key=lambda x: cv2.contourArea(x), reverse=True)
    
    _, contours1, _ = cv2.findContours(threshold1, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    contours1 = sorted(contours1, key=lambda ax: cv2.contourArea(ax), reverse=True)
    
    for cnt in contours:
        (x, y, w, h) = cv2.boundingRect(cnt)
        cv2.drawContours(roi, [cnt], -1, (0, 0, 255), 3)
        cv2.rectangle(roi, (x, y), (x + w, y + h), (255, 0, 0), 2)
        cv2.line(roi, (x + int(w/2), 0), (x + int(w/2), rows), (0, 255, 0), 2)
        cv2.line(roi, (0, y + int(h/2)), (cols, y + int(h/2)), (0, 255, 0), 2)
        break
        
    for cnt1 in contours1:
        (ax, ay, aw, ah) = cv2.boundingRect(cnt1)
        cv2.drawContours(roi1, [cnt1], -1, (0, 0, 255), 3)
        cv2.rectangle(roi1, (ax, ay), (ax + aw, ay + ah), (255, 0, 0), 2)
        cv2.line(roi1, (ax + int(aw/2), 0), (ax + int(aw/2), rows1), (0, 255, 0), 2)
        cv2.line(roi1, (0, ay + int(ah/2)), (cols1, ay + int(ah/2)), (0, 255, 0), 2)
        break
    
   
    cv2.imshow("Threshold", threshold) # 
    #cv2.imshow("gray roi", gray_roi) # 흑백
    cv2.imshow("Roi", roi) #원본
    
    cv2.imshow("Threshold1", threshold1) # 
    #cv2.imshow("gray roi1", gray_roi1) # 흑백    
    cv2.imshow("Roi1", roi1)
    
    key = cv2.waitKey(30)
    if key == 27:
        break
    
    #print("hand_x = ", x) #손 중앙 위치의 x 좌표값     
    #print("hand_y = " ,y) #손 중앙 위치의 y 좌표값
  
    #print("eye_x = " ,ax) #눈 중앙 위치의 x 좌표값    
    #print("eye_y = " ,ay) #눈 중앙 위치의 y 좌표값
    
    if 50 < ax < 650 and 300 <= ay <550: 
        print("stop ")
        dc_motorL.stop()
        dc_motorR.stop()  
        
    elif 50 < ax < 650 and 0 <= ay < 300:
        print("FORWARD")
        dc_motorR.forward(speed=0.7)
        dc_motorL.forward(speed=0.7)
        
    elif 550 <= ay <= 700 and ax >= 0:
        print("BACKWARD")
        dc_motorL.backward(speed=0.7)
        dc_motorR.backward(speed=0.5)
     

    elif ax <= 50 and ay < 550:
        print('right')
        dc_motorR.forward(speed=1.0)
        dc_motorL.forward(speed=0.5)
    
    elif 650 <= ax and ay < 550:
        print('left')
        dc_motorR.forward(speed=0.5)
        dc_motorL.forward(speed=1.0)
    
    
    if x < 100 :
        print ("LED_L")
        red_ledL.on()
        red_ledL.off()       
   
    elif x > 100:
        print ("LED_R")
        red_ledR.on()
        red_ledL.off()

cv2.destroyAllWindows()
GPIO.cleanup()

